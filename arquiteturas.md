# Padr√µes de Projeto, Arquiteturas, Testes, Banco de Dados e Boas Pr√°ticas

## 1. Outros Padr√µes de Projeto

Os padr√µes de projeto s√£o solu√ß√µes reutiliz√°veis para problemas recorrentes no desenvolvimento de software. Eles ajudam a estruturar o c√≥digo de maneira eficiente e facilitam a manuten√ß√£o e escalabilidade do sistema.

### 1.1 Factory Method

- Define uma interface para cria√ß√£o de objetos, mas permite que subclasses alterem o tipo de objetos criados.
- √ötil quando a cria√ß√£o de um objeto envolve l√≥gica complexa ou quando n√£o queremos expor diretamente a inst√¢ncia da classe.
- Exemplo:

```java
interface Produto {
    void criar();
}

class ProdutoA implements Produto {
    public void criar() {
        System.out.println("Produto A criado");
    }
}

class FabricaDeProdutos {
    public static Produto criarProduto(String tipo) {
        if (tipo.equals("A")) {
            return new ProdutoA();
        }
        throw new IllegalArgumentException("Tipo desconhecido");
    }
}
```

### 1.2 Singleton

- Garante que uma classe tenha apenas uma inst√¢ncia e fornece um ponto global de acesso a ela.
- Usado para gerenciar recursos compartilhados, como conex√µes de banco de dados.
- Exemplo:

```java
public class Configuracao {
    private static Configuracao instancia;
    private Configuracao() {}
    
    public static Configuracao getInstance() {
        if (instancia == null) {
            instancia = new Configuracao();
        }
        return instancia;
    }
}
```

### 1.3 Observer

- Define uma depend√™ncia um-para-muitos entre objetos, onde um objeto (sujeito) notifica m√∫ltiplos observadores sobre mudan√ßas de estado.
- Muito utilizado em eventos e sistemas de notifica√ß√£o.
- Exemplo:

```java
interface Observador {
    void atualizar(String mensagem);
}

class Usuario implements Observador {
    private String nome;
    public Usuario(String nome) { this.nome = nome; }
    public void atualizar(String mensagem) {
        System.out.println(nome + " recebeu: " + mensagem);
    }
}

class Notificador {
    private List<Observador> observadores = new ArrayList<>();
    public void adicionar(Observador o) { observadores.add(o); }
    public void notificarTodos(String mensagem) {
        for (Observador o : observadores) {
            o.atualizar(mensagem);
        }
    }
}
```

### 1.4 Decorator

- Permite adicionar funcionalidades a objetos dinamicamente sem modificar suas classes.
- Exemplo:

```java
interface Cafe {
    String descricao();
}

class CafeSimples implements Cafe {
    public String descricao() { return "Caf√© Simples"; }
}

class LeiteDecorator implements Cafe {
    private Cafe cafe;
    public LeiteDecorator(Cafe cafe) { this.cafe = cafe; }
    public String descricao() { return cafe.descricao() + ", com leite"; }
}
```

### 1.5 Adapter

- Converte a interface de uma classe em outra interface esperada pelos clientes.
- √ötil para integrar sistemas legados com novas APIs.
- Exemplo:

```java
class TomadaAntiga {
    public void ligarNaTomadaDoisPinos() {
        System.out.println("Ligado na tomada de dois pinos");
    }
}

class AdaptadorTomada {
    private TomadaAntiga tomada;
    public AdaptadorTomada(TomadaAntiga tomada) { this.tomada = tomada; }
    public void ligarNaTomadaTresPinos() {
        tomada.ligarNaTomadaDoisPinos();
    }
}
```

---

## 2. Arquiteturas

Diferentes arquiteturas s√£o usadas para estruturar aplica√ß√µes de forma escal√°vel e organizada.

### 2.1 Microservices vs Mon√≥lito

- **Mon√≥lito**: Aplica√ß√£o √∫nica e indivis√≠vel.
- **Microservices**: Divis√£o da aplica√ß√£o em servi√ßos independentes e interoper√°veis.
- Vantagens dos microservices: escalabilidade, deploy independente.
- Vantagens do mon√≥lito: menor complexidade inicial, mais f√°cil de testar.

### 2.2 DDD (Domain-Driven Design)

- Modela o software com base na l√≥gica do dom√≠nio de neg√≥cio.
- Utiliza conceitos como **Entidades**, **Agregados**, **Repositorios** e **Servi√ßos de Dom√≠nio**.
- Focado em colabora√ß√£o com especialistas do dom√≠nio.

### 2.3 Arquitetura Hexagonal

- Separa a l√≥gica de neg√≥cios da infraestrutura (banco de dados, frameworks, interfaces gr√°ficas).
- Utiliza portas e adaptadores para desacoplar depend√™ncias externas.
- Facilita testes e manutenibilidade.

---

## 3. Testes e Qualidade

Os testes garantem a confiabilidade e robustez do c√≥digo.

### 3.1 JUnit

- Framework para testes unit√°rios em Java.
- Exemplo de teste:

```java
@Test
public void testSoma() {
    assertEquals(4, Calculadora.somar(2, 2));
}
```

### 3.2 Mockito

- Framework para simula√ß√£o (mocking) de objetos.
- Exemplo:

```java
Mockito.when(repositorio.buscarPorId(1L)).thenReturn(new Cliente("Jo√£o"));
```

### 3.3 Testes de Integra√ß√£o no Spring

- Testes que validam a integra√ß√£o entre diferentes partes do sistema.
- Utilizam o Spring Boot Test para configurar um ambiente de testes realista.

---

## 4. Banco de Dados

Os bancos de dados armazenam e gerenciam dados da aplica√ß√£o.

### 4.1 JDBC

- API para intera√ß√£o direta com bancos de dados SQL.

### 4.2 JPA/Hibernate

- **JPA**: Especifica√ß√£o Java para persist√™ncia de dados.
- **Hibernate**: Implementa√ß√£o da JPA.

### 4.3 NoSQL

- Bancos de dados n√£o relacionais (MongoDB, Redis, Cassandra).
- Utilizados para alta escalabilidade e flexibilidade de estrutura de dados.

---

## 5. Boas Pr√°ticas

- **Clean Code**: C√≥digo limpo e de f√°cil entendimento.
- **DRY (Don't Repeat Yourself)**: Evitar duplica√ß√£o de c√≥digo.
- **KISS (Keep It Simple, Stupid)**: Manter o c√≥digo simples e direto.
- **YAGNI (You Aren't Gonna Need It)**: Implementar apenas o que √© necess√°rio.

---

## 6. Conclus√£o

Este guia fornece uma vis√£o geral de padr√µes de projeto, arquiteturas, testes, banco de dados e boas pr√°ticas essenciais para desenvolvimento de software. Al√©m disso, explorar t√≥picos complementares ajudar√° o estudante a aprofundar seus conhecimentos e desenvolver sistemas robustos e escal√°veis.

---

### üöÄ [ricardotecpro.github.io](https://ricardotecpro.github.io/)
